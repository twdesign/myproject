<?php

/**
 * @file
 * Provides a framework for selling access to local or remote resources.
 */

// License statuses.
define('COMMERCE_LICENSE_CREATED', 0);
define('COMMERCE_LICENSE_PENDING', 1);
define('COMMERCE_LICENSE_ACTIVE', 2);
define('COMMERCE_LICENSE_EXPIRED', 3);
define('COMMERCE_LICENSE_REVOKED', 4);

// License synchronization statuses.
define('COMMERCE_LICENSE_NEEDS_SYNC', 1);
define('COMMERCE_LICENSE_SYNCED', 2);
define('COMMERCE_LICENSE_SYNC_FAILED', 3);

// Refresh rates for the ajax polling.
define('COMMERCE_LICENSE_CHECK_REFRESH_RATE', 1000);
define('COMMERCE_LICENSE_CHECK_REFRESH_TIMEOUT', 40000);

/**
 * Implements hook_menu().
 */
function commerce_license_menu() {
  $items['ajax/commerce_license/%entity_object'] = array(
    'load arguments' => array('commerce_license'),
    'delivery callback' => 'ajax_deliver',
    'page callback' => 'commerce_license_complete_checkout_ajax_callback',
    'page arguments' => array(2),
    'access callback' => TRUE,
    'file' => 'includes/commerce_license.checkout_pane.inc',
  );
  $items['admin/commerce/config/license'] = array(
    'title' => 'License settings',
    'description' => 'Configure licensing settings.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('commerce_license_settings_form'),
    'access arguments' => array('administer licenses'),
    'file' => 'includes/commerce_license.admin.inc',
  );
  $items['admin/commerce/config/license/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -20,
  );

  return $items;
}

/**
 * Implements hook_ctools_plugin_type().
 */
function commerce_license_ctools_plugin_type() {
  return array(
    'type' => array(
      'use hooks' => FALSE,
      'classes' => array('class'),
    ),
  );
}

/**
 * Implements hook_ctools_plugin_directory().
 */
function commerce_license_ctools_plugin_directory($module, $plugin) {
  if ($module == 'commerce_license') {
    return 'includes/plugins/' . $plugin;
  }
}

/**
 * Get the available type plugins.
 */
function commerce_license_get_type_plugins() {
  ctools_include('plugins');
  $plugins = ctools_get_plugins('commerce_license', 'type');
  foreach ($plugins as $key => $plugin) {
    if (!class_exists($plugin['class'])) {
      // Invalid class specified.
      unset($plugins[$key]);
      continue;
    }
    $r = new ReflectionClass($plugin['class']);
    if (!$r->hasMethod('isValid') || !call_user_func(array($plugin['class'], 'isValid'))) {
      // Invalid plugin specified.
      unset($plugins[$key]);
      continue;
    }
  }
  uasort($plugins, 'ctools_plugin_sort');
  return $plugins;
}

/**
 * Implements hook_entity_info().
 */
function commerce_license_entity_info() {
  $return = array(
    'commerce_license' => array(
      'label' => t('Commerce License'),
      'controller class' => 'EntityBundlePluginEntityController',
      'base table' => 'commerce_license',
      'module' => 'commerce_license',
      'bundle plugin' => array(
        'plugin type' => 'type',
        // The name of the class to use when loading an invalid bundle.
        'broken class' => 'CommerceLicenseBroken',
      ),
      'fieldable' => TRUE,
      'entity keys' => array(
        'id' => 'license_id',
        'bundle' => 'type',
      ),
      'view modes' => array(
        'full' => array(
          'label' => t('Full'),
          'custom settings' => TRUE,
        ),
        'line_item' => array(
          'label' => t('Line item summary'),
          'custom settings' => TRUE,
        ),
      ),
      'metadata controller class' => 'CommerceLicenseMetadataController',
      'views controller class' => 'CommerceLicenseViewsController',
      'access callback' => 'commerce_license_access',
      'access arguments' => array(
        'user key' => 'uid',
      ),
      'inline entity form' => array(
        'controller' => 'CommerceLicenseInlineEntityFormController',
      ),
    ),
  );
  foreach (commerce_license_get_type_plugins() as $plugin_name => $plugin) {
    $return['commerce_license']['bundles'][$plugin_name] = array(
      'label' => $plugin['title'],
    );
  }
  return $return;
}

/**
 * Implements hook_theme().
 */
function commerce_license_theme() {
  return array(
    'commerce_license' => array(
      'render element' => 'elements',
      'template' => 'theme/commerce_license',
    ),
  );
}

/**
 * Implements hook_views_api().
 */
function commerce_license_views_api() {
  return array(
    'version' => 3,
    'path' => drupal_get_path('module', 'commerce_license') . '/includes/views',
  );
}

/**
 * Implements hook_permission().
 */
function commerce_license_permission() {
  return array(
    'administer licenses' => array(
      'title' => t('Administer licenses'),
      'restrict access' => TRUE,
    ),
    'view own licenses' => array(
      'title' => t('View own licenses'),
    ),
  );
}

/**
 * Checks license access for various operations.
 *
 * @param $op
 *   The operation being performed. One of 'view', 'update', 'create' or
 *   'delete'.
 * @param $license
 *   Optionally a license to check access for or for the create operation the
 *   product type.
 *   If nothing is given access permissions for all licenses are returned.
 * @param $account
 *   The user to check for. Leave it to NULL to check for the current user.
 */
function commerce_license_access($op, $license = NULL, $account = NULL) {
  if (!isset($account)) {
    $account = $GLOBALS['user'];
  }

  // Grant all access to the admin user.
  if (user_access('administer licenses', $account)) {
    return TRUE;
  }

  if (isset($license) && $op == 'view') {
    // If there's no user attached, the license is still in checkout, so
    // allow it to be viewed freely.
    if ($license->uid == 0) {
      return TRUE;
    }
    return (($license->uid == $account->uid) && user_access('view own licenses', $account));
  }

  return FALSE;
}

/**
 * Access callback for the commerce_license_plugin_access_sync access plugin.
 *
 * Determines if the advancedqueue module is enabled, and the user has access
 * to administer the licenses.
 */
function commerce_license_sync_access($account = NULL) {
  return module_exists('advancedqueue') && user_access('administer licenses', $account);
}

/**
 * Implements hook_commerce_checkout_pane_info().
 */
function commerce_license_commerce_checkout_pane_info() {
  $checkout_panes = array();
  $checkout_panes['commerce_license'] = array(
    'title' => t('License information'),
    'file' => 'includes/commerce_license.checkout_pane.inc',
    'base' => 'commerce_license_information',
    'page' => 'checkout',
    'fieldset' => FALSE,
    'enabled' => FALSE,
  );
  $checkout_panes['commerce_license_complete'] = array(
    'title' => t('License completion message'),
    'file' => 'includes/commerce_license.checkout_pane.inc',
    'base' => 'commerce_license_complete',
    'page' => 'complete',
    'fieldset' => FALSE,
    'enabled' => FALSE,
  );

  return $checkout_panes;
}

/**
 * Implements hook_flush_caches().
 *
 * Ensures that products and line items have the required license fields.
 */
function commerce_license_flush_caches() {
  $product_types = variable_get('commerce_license_product_types', array());
  $product_types = array_filter($product_types);
  commerce_license_configure_product_types($product_types);

  $line_item_types = variable_get('commerce_license_line_item_types', array());
  $line_item_types = array_filter($line_item_types);
  commerce_license_configure_line_item_types($line_item_types);
}

/**
 * Checks whether the user has an active license for the given product.
 *
 * @param $product
 *   The product entity.
 * @param $account
 *   The account to check for. If not given, the current user is used instead.
 *
 * @return
 *   TRUE if an active license exists, FALSE otherwise.
 */
function commerce_license_exists($product, $account = NULL) {
  global $user;

  if (!$account) {
    $account = $user;
  }

  $results = &drupal_static(__FUNCTION__, array());
  $uid = $account->uid;
  $product_id = $product->product_id;
  if (empty($results[$uid]) || empty($results[$uid][$product_id])) {
    $query = new EntityFieldQuery;
    $query
      ->entityCondition('entity_type', 'commerce_license')
      ->propertyCondition('status', COMMERCE_LICENSE_ACTIVE)
      ->propertyCondition('product_id', $product_id)
      ->propertyCondition('uid', $uid)
      ->count();
    $results[$uid][$product_id] = $query->execute();
  }

  return $results[$uid][$product_id];
}

/**
 * Implements hook_commerce_line_item_presave().
 *
 * Ensures that each saved line item has a matching license with the
 * correct product id.
 */
function commerce_license_commerce_line_item_presave($line_item) {
  $line_item_types = variable_get('commerce_license_line_item_types', array());
  $line_item_types = array_filter($line_item_types);
  // This is not a license line item type, stop here.
  if (!in_array($line_item->type, $line_item_types)) {
    return;
  }

  $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $line_item);
  $product = $line_item_wrapper->commerce_product->value();
  // The line item has a license, maintain its product_id value.
  if (!empty($line_item->commerce_license)) {
    $license = $line_item_wrapper->commerce_license->value();
    if (empty($license->product_id) || $license->product_id != $product->product_id) {
      $license->product_id = $line_item_wrapper->commerce_product->product_id->value();
      $license->save();
    }
  }
  // The line item has no license, create it if the product is licensable.
  if (empty($line_item->commerce_license) && !empty($product->commerce_license_type)) {
    $type = $line_item_wrapper->commerce_product->commerce_license_type->value();
    $license = entity_create('commerce_license', array('type' => $type));
    $license->product_id = $line_item_wrapper->commerce_product->product_id->value();
    $license->save();
    $line_item_wrapper->commerce_license = $license;
  }
}

/**
 * Implements hook_commerce_line_item_delete().
 *
 * Deletes the associated license when removing a line item.
 */
function commerce_license_commerce_line_item_delete($line_item) {
  if (!empty($line_item->commerce_license)) {
    entity_delete('commerce_license', $line_item->commerce_license[LANGUAGE_NONE][0]['target_id']);
  }
}

/**
 * Implements hook_commerce_order_update().
 *
 * Ensures the license is assigned to the correct user.
 */
function commerce_license_commerce_order_update($order) {
  $licenses = commerce_license_get_order_licenses($order);
  foreach ($licenses as $license) {
    if ($license->uid != $order->uid) {
      $license->uid = $order->uid;
      entity_save('commerce_license', $license);
    }
  }
}

/**
 * Implements hook_commerce_payment_order_paid_in_full().
 *
 * Updates the status of all licenses attached to a paid order.
 */
function commerce_license_commerce_payment_order_paid_in_full($order, $transaction) {
  $licenses = commerce_license_get_order_licenses($order);
  foreach ($licenses as $license) {
    if ($license instanceof CommerceLicenseSynchronizableInterface) {
      $license->status = COMMERCE_LICENSE_PENDING;
      $license->save();
      commerce_license_enqueue_sync($license, $order);
    }
    else {
      $license->status = COMMERCE_LICENSE_ACTIVE;
      $license->save();
    }
  }
}

/**
 * Returns all licenses found on an order.
 *
 * @param $order
 *   The order entity.
 * @param $configurable
 *   Whether to only take configurable licenses.
 *
 * @return
 *   An array of all found licenses, keyed by license id.
 */
function commerce_license_get_order_licenses($order, $configurable = FALSE) {
  $licenses = array();
  $wrapper = entity_metadata_wrapper('commerce_order', $order);
  foreach ($wrapper->commerce_line_items as $line_item_wrapper) {
    if (isset($line_item_wrapper->commerce_license)) {
      $license = $line_item_wrapper->commerce_license->value();
      if ($license && (!$configurable || $license->isConfigurable())) {
        $licenses[$license->license_id] = $license;
      }
    }
  }

  return $licenses;
}

/**
 * Enqueues a license for synchronization.
 *
 * @param $license
 *   The license entity.
 * @param $order
 *   An optional order entity, if the function is called in an order context.
 *   Used to set a more precise queue item title.
 */
function commerce_license_enqueue_sync($license, $order = NULL) {
  $license->wrapper->sync_status = COMMERCE_LICENSE_NEEDS_SYNC;
  $license->wrapper->save();

  $queue = DrupalQueue::get('commerce_license_synchronization');
  // Prepare a friendly title for the queue item.
  if ($order) {
    $args = array(
      '@license_id' => $license->license_id,
      '@number' => $order->order_number,
    );
    $item_title = t('License #@license_id (Order #@number)', $args);
  }
  else {
    $args = array('@license_id' => $license->license_id);
    $item_title = t('License #@license_id', $args);
  }

  $task = array(
    'uid' => $license->uid,
    'license_id' => $license->license_id,
    'title' => $item_title,
  );
  $queue->createItem($task);
}

/**
 * Implements hook_cron().
 *
 * Enqueues licenses for expiration.
 * The queue worker will load them one by one, change their status (allowing
 * other modules to respond via Rules and hooks), and if synchronizable,
 * enqueue them for synchronization.
 */
function commerce_license_cron() {
  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'commerce_license')
    ->propertyCondition('status', COMMERCE_LICENSE_ACTIVE)
    ->propertyCondition('expires', REQUEST_TIME, '<=');
  $results = $query->execute();
  if (!empty($results['commerce_license'])) {
    foreach (array_keys($results['commerce_license']) as $license_id) {
      $queue = DrupalQueue::get('commerce_license_expiration');
      $task = array(
        'license_id' => $license_id,
        'title' => t('License #@license_id', array('@license_id' => $license_id)),
      );
      $queue->createItem($task);
    }
  }
}

/**
 * Implements hook_advanced_queue_info().
 */
function commerce_license_advanced_queue_info() {
  return array(
    'commerce_license_expiration' => array(
      'worker callback' => 'commerce_license_expiration_queue_process'
    ),
    'commerce_license_synchronization' => array(
      'worker callback' => 'commerce_license_synchronization_queue_process',
    ),
  );
}

/**
 * Implements hook_cron_queue_info().
 *
 * Provides an expiration queue processed on cron, as a fallback if the
 * advancedqueue module is missing.
 */
function commerce_license_cron_queue_info() {
  if (!module_exists('advancedqueue')) {
    return array(
      'commerce_license_expiration' => array(
        'worker callback' => 'commerce_license_expiration_queue_process',
        'time' => 60,
      ),
    );
  }
}

/**
 * Worker callback for expiring licenses.
 */
function commerce_license_expiration_queue_process($item) {
  $license = entity_load_single('commerce_license', $item->data['license_id']);
  $license->status = COMMERCE_LICENSE_EXPIRED;
  $license->save();
  // If the license is synchronizable, queue it for synchronization.
  if ($license instanceof CommerceLicenseSynchronizableInterface) {
    commerce_license_enqueue_sync($license);
  }

  if (module_exists('advancedqueue')) {
    // If advancedqueue is used, return the proper status.
    return array(
      'status' => ADVANCEDQUEUE_STATUS_SUCCESS,
      'result' => 'Processed license #' . $license->license_id,
    );
  }
}

/**
 * Worker callback for synchronizing licenses.
 */
function commerce_license_synchronization_queue_process($item) {
  $license = entity_load_single('commerce_license', $item->data['license_id']);
  $synchronize = $license->synchronize();
  if (!$synchronize) {
    $license->wrapper->sync_status = COMMERCE_LICENSE_SYNC_FAILED;
    $license->wrapper->save();
    return array(
      'status' => ADVANCEDQUEUE_STATUS_FAILURE,
      'result' => 'Synchronization failed for license #' . $license->license_id,
    );
  }

  // A pending license was just activated, update its status.
  if ($license->status == COMMERCE_LICENSE_PENDING) {
    $license->wrapper->status = COMMERCE_LICENSE_ACTIVE;
  }
  $license->wrapper->sync_status = COMMERCE_LICENSE_SYNCED;
  $license->wrapper->save();
  // Fire a rules event and a hook, allowing developers to respond
  // to a license synchronization (sending a notification mail, for instance).
  rules_invoke_all('commerce_license_synchronize', $license);

  return array(
    'status' => ADVANCEDQUEUE_STATUS_SUCCESS,
    'result' => 'Processed license #' . $license->license_id,
  );
}

/**
 * Ensures that the provided product types have the required license fields.
 *
 * Fields:
 * - commerce_license_type: a list(text) field pointing to a license type.
 * - commerce_license_duration: a text field storing strtotime values.
 *
 * @param $types
 *   An array of product type machine names.
 */
function commerce_license_configure_product_types($types) {
  $field = field_info_field('commerce_license_type');
  if (!$field) {
    $field = array(
      'field_name' => 'commerce_license_type',
      'type' => 'list_text',
      'locked' => TRUE,
      'settings' => array(
        'allowed_values_function' => 'commerce_license_types_allowed_values',
      ),
    );
    field_create_field($field);
  }

  $existing = array();
  if (!empty($field['bundles']['commerce_product'])) {
    $existing = $field['bundles']['commerce_product'];
  }
  // Create instances on newly configured product types.
  foreach (array_diff($types, $existing) as $new_bundle) {
    $instance = array(
      'field_name' => 'commerce_license_type',
      'entity_type' => 'commerce_product',
      'bundle' => $new_bundle,
      'label' => t('License type'),
      'required' => TRUE,
      'widget' => array(
        'type' => 'options_select',
      ),
    );
    field_create_instance($instance);
  }
  // Remove instances from product types that can no longer have licenses.
  foreach (array_diff($existing, $types) as $removed_bundle) {
    $instance = field_info_instance('commerce_product', 'commerce_license_type', $removed_bundle);
    field_delete_instance($instance, TRUE);
  }

  $field = field_info_field('commerce_license_duration');
  if (!$field) {
    $field = array(
      'field_name' => 'commerce_license_duration',
      'type' => 'number_integer',
      'locked' => TRUE,
    );
    field_create_field($field);
  }

  $existing = array();
  if (!empty($field['bundles']['commerce_product'])) {
    $existing = $field['bundles']['commerce_product'];
  }
  // Create instances on newly configured product types.
  foreach (array_diff($types, $existing) as $new_bundle) {
    $instance = array(
      'field_name' => 'commerce_license_duration',
      'entity_type' => 'commerce_product',
      'bundle' => $new_bundle,
      'label' => t('License expiration'),
      'required' => TRUE,
      'widget' => array(
        'type' => 'commerce_license_duration',
      ),
    );
    field_create_instance($instance);
  }
  // Remove instances from product types that can no longer have licenses.
  foreach (array_diff($existing, $types) as $removed_bundle) {
    $instance = field_info_instance('commerce_product', 'commerce_license_duration', $removed_bundle);
    field_delete_instance($instance, TRUE);
  }
}

/**
 * Ensures that the provided line item types have the required license fields.
 *
 * Fields:
 * - commerce_license: an entityreference field pointing to a license.
 *
 * @param $types
 *   An array of line item type machine names.
 */
function commerce_license_configure_line_item_types($types) {
  $field = field_info_field('commerce_license');
  if (!$field) {
    $field = array(
      'settings' => array(
        'handler' => 'base',
        'target_type' => 'commerce_license',
      ),
      'field_name' => 'commerce_license',
      'type' => 'entityreference',
    );
    field_create_field($field);
  }

  $existing = array();
  if (!empty($field['bundles']['commerce_line_item'])) {
    $existing = $field['bundles']['commerce_line_item'];
  }
  // Create instances on newly configured line item types.
  foreach (array_diff($types, $existing) as $new_bundle) {
    $instance = array(
      'label' => 'License',
      'field_name' => 'commerce_license',
      'entity_type' => 'commerce_line_item',
      'bundle' => $new_bundle,
      'required' => TRUE,
    );
    // Configure IEF, if available.
    if (module_exists('inline_entity_form')) {
      $instance['widget'] = array(
        'type' => 'inline_entity_form_license',
      );
    }

    field_create_instance($instance);
  }
  // Remove instances from line item types that can no longer have licenses.
  foreach (array_diff($existing, $types) as $removed_bundle) {
    $instance = field_info_instance('commerce_line_item', 'commerce_license', $removed_bundle);
    field_delete_instance($instance, TRUE);
  }
}

/**
 * Returns a list of all possible license statuses.
 */
function commerce_license_status_options_list() {
  return array(
    COMMERCE_LICENSE_CREATED => t('Created'),
    COMMERCE_LICENSE_PENDING => t('Pending'),
    COMMERCE_LICENSE_ACTIVE => t('Active'),
    COMMERCE_LICENSE_EXPIRED => t('Expired'),
    COMMERCE_LICENSE_REVOKED => t('Revoked'),
  );
}

/**
 * Returns the access details of an activated license, or "N/A" if the license
 * hasn't been activated yet.
 */
function commerce_license_get_access_details($license) {
  if ($license->status > COMMERCE_LICENSE_PENDING) {
    return $license->accessDetails();
  }
  else {
    // This license hasn't been activated yet.
    return t('N/A');
  }
}

/**
 * Allowed values callback for license types.
 */
function commerce_license_types_allowed_values($field, $instance, $entity_type, $entity) {
  $types = &drupal_static(__FUNCTION__, array());
  if (empty($types)) {
    foreach (commerce_license_get_type_plugins() as $plugin_name => $plugin_info) {
      $types[$plugin_name] = $plugin_info['title'];
    }

    // Allow the list to be altered.
    drupal_alter('commerce_license_types_list', $types, $entity);
  }
  return $types;
}

/**
 * Implements hook_field_widget_info().
 */
function commerce_license_field_widget_info() {
  $widgets = array();
  if (module_exists('inline_entity_form')) {
    $widgets['inline_entity_form_license'] = array(
      'label' => t('Inline Entity Form - Commerce License'),
      'field types' => array('entityreference'),
      'settings' => array(
        'fields' => array(),
        'type_settings' => array(),
      ),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_NONE,
      ),
    );
  }
  $widgets['commerce_license_duration'] = array(
    'label' => t('License expiration'),
    'field types' => array('text'),
  );

  return $widgets;
}

/**
 * Implements hook_field_widget_settings_form().
 */
function commerce_license_field_widget_settings_form($field, $instance) {
  if ($instance['widget']['type'] == 'inline_entity_form_license') {
    return inline_entity_form_field_widget_settings_form($field, $instance);
  }
}

/**
 * Implements hook_field_widget_error().
 */
function commerce_license_field_widget_error($element, $error, $form, &$form_state) {
  form_error($element['value'], $error['message']);
}

/**
 * Implements hook_field_widget_form().
 */
function commerce_license_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  if ($instance['widget']['type'] == 'inline_entity_form_license') {
    // Using #title_display = invisible doesn't work here.
    $element['#title'] = '';
    if (!empty($form_state['line_item'])) {
      $line_item_wrapper = entity_metadata_wrapper('commerce_line_item', $form_state['line_item']);
      $product = $line_item_wrapper->commerce_product->value();
      if (empty($product->commerce_license_type)) {
        // This product is not licensable.
        return array();
      }

      $license_type = $line_item_wrapper->commerce_product->commerce_license_type->value();
      // Inject the desired bundle.
      $field['settings']['handler_settings']['target_bundles'] = array($license_type);
    }
    // Workaround the IEF condition.
    $instance['widget']['type'] = 'inline_entity_form_single';
    $element = inline_entity_form_field_widget_form($form, $form_state, $field, $instance, $langcode, $items, $delta, $element);
    // Remove the fieldset around the license form, it's not needed.
    $element['#type'] = 'container';

    return $element;
  }
  elseif ($instance['widget']['type'] == 'commerce_license_duration') {
    $element += array(
      '#type' => 'container',
      '#attached' => array(
        'css' => array(
          drupal_get_path('module', 'commerce_license') . '/theme/commerce-license.css',
        ),
      ),
      '#attributes' => array(
        'class' => array('commerce-license-duration-wrapper'),
      ),
      '#element_validate' => array('commerce_license_duration_validate'),
    );

    // Move description to the top
    if (!empty($element['#description'])) {
      $element['description'] = array(
        '#markup' => '<div class="description">' . $element['#description'] . '</div>',
        '#weight' => -10,
      );
      unset($element['#description']);
    }

    $default_mode = 'unlimited';
    $default_value = 5;
    $default_unit = 86400;
    if (!empty($items[0]) && !empty($items[0]['value'])) {
      $default_mode = 'limited';
      list($default_value, $default_unit) = commerce_license_duration_from_timestamp($items[0]['value']);
    }

    $element['mode'] = array(
      '#type' => 'radios',
      '#title' => $element['#title'],
      '#options' => array(
        'unlimited' => t('Unlimited'),
        'limited' => t('Limited'),
      ),
      '#default_value' => $default_mode,
      '#attributes' => array('class' => array('commerce-license-duration-mode')),
    );
    // Get the correct path to the mode element, taking into account field
    // parents (set when IEF is used, for example).
    $mode_parents = array($element['#field_name'], LANGUAGE_NONE, 0, 'mode');
    $mode_parents = array_merge($element['#field_parents'], $mode_parents);
    $mode_path = array_shift($mode_parents);
    foreach ($mode_parents as $mode_parent) {
      $mode_path .= "[$mode_parent]";
    }
    $description = t('Note: Months are 30 days long');
    $element['duration'] = array(
      '#type' => 'container',
      'value' => array(
        '#type' => 'textfield',
        '#title' => t('Duration'),
        '#title_display' => 'invisible',
        '#size' => 5,
        '#default_value' => $default_value,
        '#element_validate' => array('element_validate_integer_positive'),
      ),
      'unit' => array(
        '#type' => 'select',
        '#default_value' => $default_unit,
        '#options' => commerce_license_duration_units(),
      ),
      'description' => array(
        '#markup' => '<div class="description">' . $description . '</div>',
      ),
      '#attributes' => array('class' => array('commerce-license-duration container-inline')),
      '#states' => array(
        'visible' => array(
          ':input[name="' . $mode_path . '"]' => array('value' => 'limited'),
        ),
      ),
    );

    return $element;
  }
}

/**
 * #element_validate callback for the commerce_license_duration widget.
 */
function commerce_license_duration_validate($element, &$form_state) {
  // 0 is interpreted as "unlimited".
  $value = array('value' => 0);

  if ($element['mode']['#value'] == 'limited') {
    $duration = $element['duration'];
    $duration_value = trim($duration['value']['#value']);
    // Can't use #required on the value element because it shouldn't validate
    // when the mode is set to 'unlimited'.
    if (empty($duration_value)) {
      form_error($element, t('%name field is required.', array('%name' => $element['#title'])));
      form_set_value($element, $value, $form_state);
      return;
    }

    // Convert value into unix timestamp.
    if (!empty($duration['unit']['#value'])) {
      $duration_value *= $duration['unit']['#value'];
    }
    $value['value'] = intval($duration_value);
  }

  form_set_value($element, $value, $form_state);
}

/**
 * Returns all defined duration units.
 *
 * @return
 *   An array of duration units, keyed by their unix timestamp values.
 */
function commerce_license_duration_units() {
  return array(
    365*86400 => t('years'),
    30*86400 => t('months'),
    7*86400 => t('weeks'),
    86400 => t('days'),
    3600 => t('hours'),
    60 => t('minutes'),
  );
}

/**
 * Converts a unix timestamp to a duration with a unit (1 day, 2 weeks, etc).
 *
 * @param $timestamp
 *   The unix timestamp to convert.
 *
 * @return
 *   An array with the value as the first element, and the unit as the second.
 */
function commerce_license_duration_from_timestamp($timestamp) {
  if (!is_scalar($timestamp)) {
    return array();
  }

  // Get the highest unit wholly contained in the value.
  $unit = 60;
  $units = commerce_license_duration_units();
  foreach ($units as $multiplier => $label) {
    if ($timestamp % $multiplier == 0) {
      $unit = $multiplier;
      break;
    }
  }

  // Return the value and the unit.
  return array($timestamp / $unit, $unit);
}
